% ofdm модуляция
clear; clc;

bits = rand(50);
bits = bits > 0.5;

fprintf('Комплексные символы: ');
c = [];
n = 0;

for i = 1:2:length(bits)
    complex = (1/sqrt(2))* ((1-2*bits(i)) + 1j*(1-2*bits(i+1)));
    fprintf('(%g%+gi) ', real(complex), imag(complex));
    c = [c, complex];
    n = n + 1;
end

fprintf('\n');
fprintf('Кол-во символов на выходе модулятора = %d', n);
fprintf('\n');

RS = 9;
Nqpsk = n;  % кол-во qpsk символов
NRS = floor(Nqpsk/RS) + 1; % кол-во опорных поднесущих
indexes = zeros(1, NRS); 
current_idx = 1;

opor_sig = ones(1, NRS);

%% расчет индексов опорных поднесущих

for i = 1:RS:(1 + (NRS-1)*RS)
    indexes(current_idx) = i;
    current_idx = current_idx + 1;
end

fprintf('\n');
disp('Индексы опорных поднесущих:');
disp(indexes);

%% размещение опорного сигнала

signal = zeros(1, Nqpsk + NRS);
j = 1;
z = 1;

for i = 1:length(signal)
     if j <= NRS && i == indexes(j)
        signal(i) = opor_sig(j);
        j = j + 1;
    else
        signal(i) = c(z);
        z = z + 1;
    end

end

fprintf('\n');
disp('Полный сигнал: ');
disp(signal);

%% добавление нулевого защитного интервала

C = 1/4;
Nz = C * (NRS + Nqpsk);  % кол-во нулевых поднесущих
zero = zeros(1, Nz);

signal_with_zeros = [zero, signal, zero];

fprintf('\n');
disp('Сигнал с защитными нулями: ');
disp(signal_with_zeros);

%% обратное ДПФ

signal_fft = ifft(signal_with_zeros);

%% добавление циклического префикса
   
Tcp = floor(length(signal_fft) / 8);        % длина префикса

fprintf('Длина циклического префикса: %d\n', Tcp);

prefix = signal_fft(end-Tcp+1:end);

final_signal = [prefix, signal_fft];

% len = Tcp + NRS + Nqpsk + 2*Nz;
% fprintf('\n Необходимая длина вектора = %d \n', len);

fprintf('\nИтоговый вектор (длина = %d):\n', length(final_signal));
disp(final_signal);